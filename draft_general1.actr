;;; Model of go fish - general stradegy
;;;

(add-dm
    (goal isa state_control state retrieve_state)
    (goal2 isa round state wait)
    (goal3 isa decision current_player self)
    (p1 isa player-order current player1 next player2 end false) ;;;player 1, 2, 3 is identified in swfit
    (p2 isa player-order current player2 next player3 end false)
    (p3 isa player-order current player3 next player1 end true)
)

(set-all-baselevels -100 10) ;; time offset and number of references
 
(p start-retrieve-state ;;; retrive state from action module
	=goal>
		isa state_control
		state retrieve_state
==>
	+action>
		isa decision
	=goal>
		state retrieved
)

(p retrieved-state
	=goal>
		isa state_control
		state retrieved
	=action>
		isa decision
		state =state ;;; if the state say the player is the first one to act. 
		;;; It will select the first card and first opponent to act on outside the production rules
		;;; and send back to the production rule to record it 
		;;; start-first part will be coded in swift. the return status will be go fish and succeed
		;;;If the state said "wait" or "start". card_ask and opponent_player will be set to nil or 0
	    card_ask =card_ask
	    opponent_player =player
	    card_get =card_get
	    set =set ;;;the card is already set or not
==>
	=goal>
		isa state_control
		state =state
	-action>
)

;;;state list of the player himself

;;;start --- of a new turn(not the first round)
;;;wait/memorize ---it's not your turn. Wait and memorize
;;;ask --- ask for cards

(p wait
	=goal>
		isa state_control
		state wait
==>
	+action>
		isa round
	=goal>
		isa state_control
		state memorize
)

(p memorize ;;;stradegy when it's not your turn
    =goal>
        isa state_control
        state memorize
    =action>
        isa round
        current_player =current_player ;;; not self definitly
        opponent_player =opponent_player ;;; can be the player himself. If so, return "self" and update deck in swift
        card =card
        state =state ;;;succeed-gofish write into round? remember the opposite relation?
        card_owned =card_owned ;;; did you own this card in your deck true/false
==>
    +imaginal>
        isa sequence
        card =card
        player =current_player
        card_owned =card_owned
        ;;;;conservative stradegy - also remember the negative relationship 
    =goal>
    	isa state_control
		state retrieve_state ;;; retrieve the latest status
		;;; if it's wait, go to wait-stradegy
		;;; if it's start, then it's your turn
    -action>
)

(p succeed_round_A ;;;stradegy when told succeed
    =goal>
        isa decision
        state succeed
        card_ask =card
	    opponent_player =player
    ?retrieval>
        state  free
==>
    =goal>
        isa decision
        state next
    +retrieval>
    	isa player-order
    	current =player
)

(p succeed_round_next
	=goal>
		isa decision
		state next
		card_ask =card
	=retrieval>
		next =player
		-end true
==>
	=goal>
		isa decision
		state ask
	+action>
		isa decision
		state ask ;;; is it possible to change state like this?
		opponent_player =player
		card_ask =card
	+goal>
		isa state_control
		state retrieved ;;; going back to retrieve cards
	-retrieval>
)

(p succeed_round_end_A ;;;stradegy when told succeed, also linked to start_g1_success_nextB
    =goal>
        isa decision
        state succeed
        card_ask =card
	    set false
    =retrieval>
    	next =player
    	end true ;;; this exposed card is retrieved
==>
	+goal>
		isa state_control
		state start
    +imaginal>
    	isa exposed_cards ;;; the card is asked for all player
    	card =card
    	player all
    -retrieval>
)

(p succeed_round_end_B ;;;stradegy when told succeed, also linked to start_g1_success_nextB
    =goal>
        isa decision
        state succeed
        card_ask =card
	    set true
    =retrieval>
    	next =player
    	end true ;;; this exposed card is retrieved
==>
	+goal>
		isa state_control
		state start
    -retrieval>
)


(p gofishA ;;;stradegy when go fish
    =goal>
        isa decision
        state gofish
        opponent_player =player
        card_asked =card
    ?retrieval>
        state  free
==>
    +goal>
        isa state_control
        state wait
    +imaginal>
    	isa exposed_cards
    	card =card
    	player =player
    	at_hand true
)

(p gofishB ;;;stradegy when go fish, linked to start_g1_success_nextB
    =goal>
        isa decision
        state gofish
        opponent_player =player
        card_asked =card
    =retrieval>
    	next =player
    	end true ;;; this exposed card 
==>
    +goal>
        isa state_control
        state wait
    +imaginal>
    	isa exposed_cards ;;; the card is asked for all player
    	card =card
    	player all
    -retrieval>
)


(p start_general1 ;;; a new turn for the player with previous info
;;; ask for exposed cards
    =goal>
        isa state_control
        state start
==>
    =goal>
        isa state_control
        state choosing_g1
    +retrieval>
        isa exposed_cards 
        at_hand true
)

(p start_g1_failureA ;;; attempt to switch to general 2
    =goal>
        isa state_control
        state choosing_g1
    ?retrieval>
        state  error ;;; no card exposed in memory
==>
    =goal>
        isa state_control
        state choosing_g2
    -retrieval>
    +retrieval>
        isa sequence
        card_owned true 
)

(p start_g2_failure
    =goal>
        isa state_control
        state choosing_g2
    ?retrieval>
        state  error ;;; can't remember who has my card
==>
;;;;;to be continued
)

(p start_g1_success
    =goal>
        isa state_control
        state choosing_g1
    =retrieval>
        isa exposed_cards
        card =card
    	player =player
==>
	=goal>
        isa state_control
        state retrieved
        card =card
        player =player
	+action>
    	isa decision
    	card_asked =card
)
;;;;stop here, cannot think, need some sleep
(p start_g1_success-s
    =goal>
        isa decision
        state retrieved
    =retrieval>
        isa exposed_cards
        card =card
    	player =player
==>
	=goal>
        isa state_control
        state choosing_g1_p
        card =card
	-retrieval>
	+retrieval>
    	isa player-order
    	current =player
)

(p start_g1_success-f
    =goal>
        isa state_control
        state fail ;; the card is not in deck
    =retrieval>
        isa exposed_cards
        card =card
    	player =player
==>
	=goal>
        isa state_control
        state start
    =retrieval>
        isa exposed_cards
        card =card
    	player =player
    	at_hand false
	-retrieval>
)


(p start_g1_success_nextA
    =goal>
        isa state_control
        state choosing_g1_p
        card =card
    =retrieval>
    	next =player
    	-end true
==>
	+goal>
        isa state_control
        state retrieved
	-retrieval>
	+action>
		isa decision
		state ask 
		opponent_player =player
		card_ask =card
)

(p start_g1_success_nextB
    =goal>
        isa state_control
        state choosing_g1_p
        card =card
    =retrieval>
    	next =player
    	end true ;;; this exposed card 
==>
	+goal>
        isa state_control
        state retrieved
	+action>
		isa decision
		state ask 
		opponent_player =player
		card_ask =card
)

(p start_g1_failureB  ;;; the asked card is not owned by the player
	=goal>
        isa decision
        state fail
        card_ask =card
==>
	+retrieval>
        isa exposed_cards
        -card =card


)


(p succeed_round ;;;stradegy when told succeed
    =goal>
        isa decision
        state succeed
        opponent_player =player
        card_ask =card
    =retrieval>
        isa player-order
        next =next_player
        -end true ;;;end of the round
==>
    =goal>
        isa decision
        state start
        opponent_player =next_player
    +action>
        isa decision
        card_ask =card
        opponent_player =next_player
    -retrieval>
    ;;;;update the cards you get????
)

(p gofish ;;;stradegy when go fish
    =goal>
        isa decision
        state gofish
        opponent_player =opponent_player 
        card =card
        state =state ;;;succeed-gofish write into round? remember the opposite relation?
        card_owned =card_owned ;;; did you own this card in your deck true/false

==>
    =goal>
        isa decision
        state wait
    +action>
        ;;; update the card_get into your cards???
        ;;;isa round ;;;interacte and get information?
)

(p wait ;;;stradegy when it's not your turn
    =goal>
        isa decision
        state wait
    =action>
        isa round
        current_player =current_player ;;; not self definitly
        opponent_player =opponent_player
        card =card
        state =state ;;;succeed-gofish write into round? remember the opposite relation?
==>
    +imaginal>
        isa sequence
        card =card
        player =current_player
        ;;;;conservative stradegy - also remember the negative relationship (who doesn't habe which)
    -action>
)


(p asked_card ;;;if succeed asked card update your cards (?)
    =goal>
        isa round
        state succeed
        opponent_player self ;;;???? map between self and real player identifier required
==>
    +action>
        ;;;update cards????

)





(goal-focus goal)

