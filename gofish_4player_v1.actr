;;; Model of go fish - 4 player mode
;;;

(add-dm
    (goal isa state_control state start_state)
    (action isa decision state first_start card_ask init opponent_player init current_player init state_round init first_starter false)
    (p1 isa player-order current player1 next player2 ) ;;;player 1, 2, 3 is mapped to different player in swfit
    (p2 isa player-order current player2 next player3 )
    (p3 isa player-order current player3 next player1 )
)

(set-all-baselevels -100 10) ;; time offset and number of references
 
(p start-retrieve-state-first ;;; retrive state from action module
	=goal>
		isa state_control
		state start_state
==>
	=goal>
		isa state_control
		state retrieving
	+action>
		isa decision
		state first_start
)

(p first_round;;; special treatment for first round
    =goal>
        isa state_control
        state retrieving
    =action>
        isa decision
        first_starter true ;;; only one player has this as true
        opponent_player =player
        card_ask =card;;; card asked
==>
    +imaginal>
        isa exposed_cards
        card =card
        player =player
	=action>
		isa decision
		first_starter false
)

(p gofish ;;;stradegy when go fish
    =goal>
        isa state_control
        state retrieving
    =action>
        isa decision
        state gofish
        first_starter false
==>
    +action>
        isa decision
        state wait_memorize
)

(p succeed ;;;stradegy when told succeed
    =goal>
        isa state_control
        state retrieving
    =action>
        isa decision
        state succeed
        first_starter false
==>
    +goal>
        isa state_control
        state start
)

(p wait-memorize ;;;stradegy when it's not your turn
    =goal>
        isa state_control
        state retrieving
    =action>
        isa decision
        state wait_memorize
        first_starter false
        current_player =current_player 
        card_ask =card  
==>
    +imaginal>
        isa sequence
        card =card
        player =current_player
    +action>
        isa decision
        state wait_memorize
)


(p start_a_new_round 
	=goal>
		isa state_control
		state retrieving
	=action>
 		isa decision
		state start
		first_starter false
        current_player =current_player ;;; player of the most recent round
        card_ask =card ;;; card asked
        state_round gofish 
==>
    =goal>
        isa state_control
        state start
    +imaginal>
        isa sequence
        card =card
        player =current_player
)

(p start_check_card ;;; check what card you have
    =goal>
        isa state_control
        state start
==>
    +goal>
        isa general_stradegy1
        state start
	+action>
		isa decision
		state checking
		card_deck first
)


(p start_general1 ;;; a new turn for the player with previous info
;;; ask for exposed cards
    =goal>
        isa general_stradegy1
        state start
    =action>
    	isa decision
    	state checking
    	card_deck =card;;; the card_deck will be updated after each checking
==>
    =goal>
        isa general_stradegy1
        state second
        card =card
    +retrieval>
        isa exposed_cards ;;; recall the exposed card.
        card =card
)

(p start_general1_f
    =goal>
        isa general_stradegy1
        state second
        card =card
    ?retrieval>
        state  error ;;; not in memory
==>
    +goal>
        isa general_stradegy1
        state start
    +action>
        isa decision
        state checking
        card_deck =card ;;; retrieve the next card
)

(p start_general1_s-f
    =goal>
        isa general_stradegy1
        state second
        card =card
    =retrieval>
        isa exposed_cards ;;; recall the exposed card.
        player all ;;; all players been asked
==>
    +goal>
        isa general_stradegy1
        state start
    +action>
        isa decision
        state checking
        card_deck =card ;; check for the next card
)

(p start_general1_s
    =goal>
        isa general_stradegy1
        state second
    =retrieval>
        isa exposed_cards ;;; recall the exposed card.
        -player all ;;; not all players been asked
        player =player
==>
    =goal>
        isa general_stradegy1
        state next-player
    +retrieval>
        isa player-order
        current =player
)

(p start_general1_s-next ;;; check the next player
    =goal>
        isa general_stradegy1
        state next-player
        card =card
    =retrieval>
        isa player-order 
        next =player
==>
    =goal>
        isa general_stradegy1
        state next-check
        player =player
    +retrieval>
        isa exposed_cards 
        card =card
        player =player
)

(p start_general1_s-next-end ;;; next player not exposed
    =goal>
        isa general_stradegy1
        state next-check
        card =card
        player =player
    ?retrieval>
        state error
==>
    +goal>
        isa state_control
        state retrieving
    +imaginal>
        isa exposed_cards
        card =card
        player =player        
    +action>
        isa decision
        state ask 
        opponent_player =player
        card_ask =card
)

(p start_general1_s-next-f ;;; next player exposed
    =goal>
        isa general_stradegy1
        state next-check
    =retrieval>
        isa exposed_cards 
        card =card
        player =player
==>
    =goal>
        isa general_stradegy1
        state last-player
    +retrieval>
        isa player-order
        current =player
)

(p start_general1_s-last ;;; check the last player
    =goal>
        isa general_stradegy1
        state last-player
        card =card
    =retrieval>
        isa player-order 
        next =player
==>
    =goal>
        isa general_stradegy1
        state last-check
        player =player
    +retrieval>
        isa exposed_cards 
        card =card
        player =player
)

(p start_general1_s-last-end ;;; last player not exposed
    =goal>
        isa general_stradegy1
        state last-check
        card =card
        player =player
    ?retrieval>
        state error
==>
    +goal>
        isa state_control
        state retrieving
    +imaginal>
        isa exposed_cards
        card =card
        player =player        
    +action>
        isa decision
        state ask 
        opponent_player =player
        card_ask =card
)

(p start_general1_s-last-f ;;; last player exposed
    =goal>
        isa general_stradegy1
        state last-check
    =retrieval>
        isa exposed_cards 
        card =card
==>
    +goal>
        isa general_stradegy1
        state start
    +imaginal>
        isa exposed_cards
        card =card
        player all ;;; mark        
    -retrieval>
    +action>
        isa decision
        state checking
        card_deck =card ;; check for the next card
)

(p g1_failure ;;; reach the end of the cards
    =goal>
        isa general_stradegy1
        state start
    =action>
    	isa decision
    	state checking_failed 
==>
    +goal>
        isa general_stradegy2
        state start
	+action>
		isa decision
		state checking
		card_deck first
)

(p g2-retrieve-memory
    =goal>
        isa general_stradegy2
        state start
    =action>
    	isa decision
    	state checking
    	card_deck =card 
==>
    =goal>
        isa general_stradegy2
        state next
        card =card
    +retrieval>
        isa sequence ;;;recall cards from sequences
        card =card
)


(p g2-retrieve-memory-f
	=goal>
		isa general_stradegy2
		state next
        card =card
	?retrieval>
		state  error 
==>
	=goal>
		isa general_stradegy2
		state start
	+action>
		isa decision
		state checking
		card_deck =card
)


(p g2-retrieve-memory-s1
	=goal>
		isa general_stradegy2
		state next
	=retrieval>
        isa sequence ;;;recall cards from sequences
        card =card
        player =player
==>
	+goal>
        isa state_control
        state retrieving
    +imaginal>
    	isa exposed_cards 
    	card =card
    	player =player 
	+action>
		isa decision
		state ask
		card_ask =card
		opponent_player =player		
)

(p general2-failure ;;;can't remeber who asked what card  before
    =goal>
		isa general_stradegy2
		state start
    =action>
    	isa decision
    	state checking_failed 
==>
    +goal>
        isa special_stradegy
        state select
    -action>
)


(p special-stradegy-choose-a ;;; select aggressive stradegy;;; random?
	=goal>
        isa special_stradegy
        state select
==>
	+goal>
        isa aggressive_stradegy
        state start
    +action>
        isa decision
        state checking
        card_deck multiple ;; check for multiple cards. if no multiple cards, return the first card
)


(p special-stradegy-choose-c ;;; select conservative stradegy
	=goal>
        isa special_stradegy
        state select
==>
	+goal>
        isa conservative_stradegy
        state start
    +retrieval>
        isa exposed_cards ;;; recall a card that have asked all the player
        player all 
)

(p aggressive-stradegy-start
	=goal>
        isa aggressive_stradegy
        state start
    =action>
        isa decision
        state checking ;;; this state can't be checking failed
        card_deck =card ;;; if no multiple cards, send back the first card (single)
==>
    +goal>
        isa state_control
        state retrieving
    +imaginal>
        isa exposed_cards 
        card =card
        player player1 
    +action>
        isa decision
        state ask
        card_ask =card
        opponent_player player1 
)


(p conservative_stradegy-startA
	=goal>
        isa conservative_stradegy
        state start
    =retrieval>
        isa exposed_cards 
        card =card
        player all 
==>
	+goal>
		isa state_control
		state retrieving
	+action>
		isa decision
		state ask
		card_ask =card
		opponent_player player1	
)

(p conservative_stradegy-startB
	=goal>
        isa conservative_stradegy
        state start
    ?retrieval>
    	state error
==>
	+goal>
        isa aggressive_stradegy
        state start
    +action>
        isa decision
        state checking
        card_deck multiple 
)

(goal-focus goal)